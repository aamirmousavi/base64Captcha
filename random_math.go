package base64Captcha

import (
	"crypto/rand"
	"encoding/binary"
	"image/color"
	"math"
	"math/big"
	mathrand "math/rand/v2"
	"strings"
)

// RandText creates random text of given size.
func RandText(size int, sourceChars string) (string, error) {
	if sourceChars == "" || size == 0 {
		return "", nil
	}

	if size >= len(sourceChars) {
		sourceChars = strings.Repeat(sourceChars, size)
	}

	sourceRunes := []rune(sourceChars)
	sourceLength := len(sourceRunes)

	text := make([]rune, size)
	for i := range text {
		nBig, err := rand.Int(rand.Reader, big.NewInt(int64(sourceLength)))
		if err != nil {
			return "", err
		}
		text[i] = sourceRunes[int(nBig.Int64())]
	}
	return string(text), nil
}

// Random get random number between min and max. 生成指定大小的随机数.
func random(min int64, max int64) (float64, error) {
	if max-min <= 0 {
		return float64(min), nil
	}
	nBig, err := rand.Int(rand.Reader, big.NewInt(max-min))
	if err != nil {
		return 0, err
	}
	return float64(min) + float64(nBig.Int64()), nil
}

// RandDeepColor get random deep color. 随机生成深色系.
func RandDeepColor() (color.RGBA, error) {

	randColor, err := RandColor()
	if err != nil {
		return color.RGBA{}, err
	}

	// increase := float64(30 + rand.Intn(255))
	increaseF, err := randFloat64Range(30, 100)
	if err != nil {
		return color.RGBA{}, err
	}
	increase := increaseF

	red := math.Abs(math.Min(float64(randColor.R)-increase, 255))

	green := math.Abs(math.Min(float64(randColor.G)-increase, 255))
	blue := math.Abs(math.Min(float64(randColor.B)-increase, 255))

	return color.RGBA{R: uint8(red), G: uint8(green), B: uint8(blue), A: uint8(255)}, nil
}

// RandLightColor get random ligth color. 随机生成浅色.
func RandLightColor() (color.RGBA, error) {
	// red := rand.Intn(55) + 200
	redN, err := rand.Int(rand.Reader, big.NewInt(55))
	if err != nil {
		return color.RGBA{}, err
	}
	red := int(redN.Int64()) + 200
	// green := rand.Intn(55) + 200
	greenN, err := rand.Int(rand.Reader, big.NewInt(55))
	if err != nil {
		return color.RGBA{}, err
	}
	green := int(greenN.Int64()) + 200
	// blue := rand.Intn(55) + 200
	blueN, err := rand.Int(rand.Reader, big.NewInt(55))
	if err != nil {
		return color.RGBA{}, err
	}
	blue := int(blueN.Int64()) + 200
	//
	return color.RGBA{R: uint8(red), G: uint8(green), B: uint8(blue), A: uint8(255)}, nil
}

// RandColor get random color. 生成随机颜色.
func RandColor() (color.RGBA, error) {
	// red := rand.Intn(255)
	redN, err := rand.Int(rand.Reader, big.NewInt(255))
	if err != nil {
		return color.RGBA{}, err
	}
	red := int(redN.Int64())
	// green := rand.Intn(255)
	greenN, err := rand.Int(rand.Reader, big.NewInt(255))
	if err != nil {
		return color.RGBA{}, err
	}
	green := int(greenN.Int64())
	var blue int
	if (red + green) > 400 {
		blue = 0
	} else {
		blue = 400 - green - red
	}
	if blue > 255 {
		blue = 255
	}
	return color.RGBA{R: uint8(red), G: uint8(green), B: uint8(blue), A: uint8(255)}, nil
}

func randIntRange(from, to int) (int, error) {
	// rand.Intn panics if n <= 0.
	if to-from <= 0 {
		return from, nil
	}
	n, err := rand.Int(rand.Reader, big.NewInt(int64(to-from)))
	if err != nil {
		return 0, err
	}
	return int(n.Int64()) + from, nil
}
func randFloat64Range(from, to float64) (float64, error) {
	n, err := rand.Int(rand.Reader, big.NewInt(1000000))
	if err != nil {
		return 0, err
	}
	return (float64(n.Int64())/1000000)*(to-from) + from, nil
}
func randBytes(n int) ([]byte, error) {
	// Since we don't have a buffer for generated bytes in siprng state,
	// we just generate enough 8-byte blocks and then cut the result to the
	// required length. Doing it this way, we lose generated bytes, and we
	// don't get the strictly sequential deterministic output from PRNG:
	// calling Uint64() and then Bytes(3) produces different output than
	// when calling them in the reverse order, but for our applications
	// this is OK.
	numBlocks := (n + 8 - 1) / 8
	b := make([]byte, numBlocks*8)
	for i := 0; i < len(b); i += 8 {

		binary.LittleEndian.PutUint64(b[i:], mathrand.Uint64())

	}
	return b[:n], nil
}

// RandomId returns a new random id key string.
func RandomId() string {
	b := randomBytesMod(idLen, byte(len(idChars)))
	for i, c := range b {
		b[i] = idChars[c]
	}
	return string(b)
}
